// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id          Int      @id @default(autoincrement())
  email       String   @unique
  name        String
  passwordHash String  @map("password_hash")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  projects      Project[]
  studySessions StudySession[]
  timerSessions TimerSession[]

  @@map("users")
}

model Project {
  id          Int      @id @default(autoincrement())
  name        String
  description String?  @db.Text
  ownerId     Int      @map("owner_id")
  isPublic    Boolean  @default(false) @map("is_public")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  owner       User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  questionSets QuestionSet[]

  @@map("projects")
}

model QuestionSet {
  id          Int      @id @default(autoincrement())
  projectId   Int      @map("project_id")
  name        String
  description String?  @db.Text
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  project     Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  questions   Question[]
  studySessions StudySession[]

  @@map("question_sets")
}

model Question {
  id            Int      @id @default(autoincrement())
  questionSetId Int      @map("question_set_id")
  questionText  String   @db.Text @map("question_text")
  answerText    String?  @db.Text @map("answer_text")
  difficulty    Int?     @default(1) // 1-5 scale
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  questionSet   QuestionSet @relation(fields: [questionSetId], references: [id], onDelete: Cascade)
  sessionAnswers SessionAnswer[]

  @@map("questions")
}

model StudySession {
  id            Int       @id @default(autoincrement())
  userId        Int       @map("user_id")
  questionSetId Int       @map("question_set_id")
  mode          String    @default("front-to-end") // "front-to-end" or "shuffle"
  startedAt     DateTime  @default(now()) @map("started_at")
  completedAt   DateTime? @map("completed_at")

  // Relations
  user           User @relation(fields: [userId], references: [id], onDelete: Cascade)
  questionSet    QuestionSet @relation(fields: [questionSetId], references: [id], onDelete: Cascade)
  sessionAnswers SessionAnswer[]
  timerSessions  TimerSession[] // One deck session can have multiple timer sessions

  @@map("study_sessions")
}

model TimerSession {
  id              Int       @id @default(autoincrement())
  deckSessionId   Int       @map("deck_session_id")        // Foreign key to StudySession (deck session)
  userId          Int       @map("user_id")                // Denormalized for easier querying

  // Timer configuration
  workDuration    Int       @default(1500) @map("work_duration")     // Work time in seconds (default 25 minutes)
  restDuration    Int       @default(300) @map("rest_duration")      // Rest time in seconds (default 5 minutes)
  isInfinite      Boolean   @default(false) @map("is_infinite")      // Whether session runs indefinitely

  // Timer tracking
  totalWorkTime   Int       @default(0) @map("total_work_time")      // Total work time spent in seconds
  totalRestTime   Int       @default(0) @map("total_rest_time")      // Total rest time spent in seconds
  cyclesCompleted Int       @default(0) @map("cycles_completed")     // Number of work+rest cycles completed
  currentPhase    String    @default("work") @map("current_phase")   // "work", "rest", "paused", "completed"
  previousPhase   String?   @map("previous_phase")                  // Phase before pausing
  elapsedTimeInPhase Int?   @default(0) @map("elapsed_time_in_phase") // Elapsed seconds in current phase when paused
  phaseStartedAt  DateTime? @map("phase_started_at")                // When current phase started

  // Session lifecycle
  startedAt       DateTime  @default(now()) @map("started_at")
  completedAt     DateTime? @map("completed_at")

  // Relations
  deckSession     StudySession @relation(fields: [deckSessionId], references: [id], onDelete: Cascade)
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  timerEvents     TimerEvent[]

  @@map("timer_sessions")
}

model SessionAnswer {
  id          Int      @id @default(autoincrement())
  sessionId   Int      @map("session_id")
  questionId  Int      @map("question_id")
  userRating  Int      @map("user_rating") // 1-5 scale
  answeredAt  DateTime @default(now()) @map("answered_at")

  // Relations
  session     StudySession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  question    Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@map("session_answers")
}

model TimerEvent {
  id            Int      @id @default(autoincrement())
  timerSessionId Int     @map("timer_session_id")   // References TimerSession only
  eventType     String   @map("event_type")  // "start", "pause", "resume", "phase_change", "cycle_complete"
  fromPhase     String?  @map("from_phase")  // Previous phase
  toPhase       String?  @map("to_phase")    // New phase
  duration      Int?     @default(0)         // Duration of previous phase in seconds
  timestamp     DateTime @default(now())

  // Relations
  timerSession  TimerSession @relation(fields: [timerSessionId], references: [id], onDelete: Cascade)

  @@map("timer_events")
}